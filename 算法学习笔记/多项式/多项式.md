# 萝莉控都能看懂的多项式（入门）

> 这里不会对数学部分过多的介绍，~~（因为不会）~~  一个成熟的萝莉控应该自己学习数学。

$$
f(x)=\sum_{i=0}^{n} a_ix^{i}
$$

默认多项式系数为$2^k$次。

## 前置知识

### 多项式的点值表示

可以用$n+1$个不同的点，表示一个多项式。

而对于$R=PQ$，有$R(x)=P(x) Q(x)$

因此在点值表达式下，我们可以$O(n)$计算多项式乘法。只需要快速进行变换即可。

### 单位根

即$x^n=1$在复数域的根。因为复数乘法是模长相乘，幅角相加。显然其$n$个根为$(\cos \frac{k}{n}2\pi,\sin \frac{k}{n} 2\pi)$ 。（就是n等分一个单位圆。）

我们将第$k$个根记为$\omega_n ^k$。

一些性质：

+ $\omega_n^{0}=1$
+ $\omega_{n}^{k}=\omega_{xn}^{xk}$
+ $\omega_{2n}^{k+n}=-\omega_{2n}^{k}$
+ $\omega_{n}^{k}=(\omega_n^{1})^k$

### 原根

满足同余式
$$
a^n \equiv  1 \mod m
$$
的最小正整数，称为$a$模$m$的**阶**，记作$\delta_m(a)$

一些性质：

+ $a,\cdots ,a^{\delta_m(a)}$模m两两不同余。
+ 若$a^n\equiv 1 \mod{m} $，则$\delta_m(a) |n$
+ 设$m$为正整数，$a,b$为整数，$\gcd(a,m)=\gcd(b,m)=1$，那么$\delta_m(ab)=\delta_m(a) \delta_m(b) \iff \gcd(\delta_m(a),\delta_m(b))=1$
+ 设$m$为正整数，$a$为整数，$k$ 是非负整数，$\gcd(a,m)=1$，那么

$$
\delta_m(a^k)=\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}
$$

设$m$为正整数，$g$为整数。若$\gcd(g,m)=1$，且$\delta_m(g)=\phi(m)$，则称$g$为模$m$的原根。

若一个数$m$有原根$g$，则$g,g^2,\cdots ,g^{\phi(m)}$构成模$m$的缩系（简化剩余系）。

一些性质：

+ 设$m\ge 3$，$\gcd(g,m)=1$，则$g$ 是模$m$的原根的充要条件是对于$\phi(m)$的每个素因数$p$，都有

$$
g^{\frac{\phi(m)}{p}} \not\equiv 1 \mod{m}
$$

王元和 Burgess证明了素数$p$的最小原根是$O(p^{0.25+\epsilon})$的，因此可以暴力枚举。

## 离散傅里叶变换（DFT）

将点值表示的$x$，定为$n$次单位根，得到点值表示，就叫离散傅里叶变换。DFT可以$O(n^2)$将两个多项式的**系数表示**与**点值表示**互相转化。

为什么用单位根呢？

设
$$
A(x)=\sum_{i=0}^{n-1}a_i x^{i}
$$
$DFT(A)=[b_0,b_1,\cdots ,b_{n-1}]$
$$
B(x)=\sum_{i=0}^{n-1}b_i x^{i}
$$
我们将单位根的倒数带入得到$[c_0,c_1,\cdots c_{n-1}]$
$$
\begin{aligned}
c_k&=\sum_{i=0}^{n-1} b_i (\omega_n^{-k})^i\\
&=\sum_{i=0}^{n-1}\left( \sum_{j=0}^{n-1} a_j (\omega_{n}^{i})^j \right)(\omega_n^{-k})^i\\
&=\sum_{j=0}^{n-1} a_j \sum_{i=0}^{n-1} (\omega_n^{j-k})^i
\end{aligned}
$$
里面的和式用等比数列求和得到
$$
\frac{1-(\omega_n^{j-k})^n}{1-\omega_n^{j-k}}
$$
发现当$j\neq k$时为0。

故上式有
$$
c_k=na_k
$$
这样就会很方便做逆变换。

具体地：系数$\to$ 点值，带入单位根；点值$\to$系数，将对应的点值当成系数，再带出单位根倒数，再除$n$。

代码

```cpp
vector<int> rev;
template<int P> vector<MInt<P>> roots{0, 1};

template<int P> constexpr MInt<P> findPrimitiveRoot() {
    MInt<P> i = 2;
    int k = __builtin_ctz(P - 1);
    while (true) {
        if (power(i, (P - 1) / 2) != 1) {
            break;
        }
        i += 1;
    }
    return power(i, (P - 1) >> k);
}

template<int P> constexpr MInt<P> primitiveRoot = findPrimitiveRoot<P>();
template<> constexpr MInt<998244353> primitiveRoot<998244353>{31};

template<int P> constexpr void dft(vector<MInt<P>> &a) { // 离散傅里叶变换
    int n = a.size();

    if (int(rev.size()) != n) {
        int k = __builtin_ctz(n) - 1;
        rev.resize(n);
        for (int i = 0; i < n; i++) {
            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;
        }
    }

    for (int i = 0; i < n; i++) {
        if (rev[i] < i) {
            swap(a[i], a[rev[i]]);
        }
    }
    if (roots<P>.size() < n) {
        int k = __builtin_ctz(roots<P>.size());
        roots<P>.resize(n);
        while ((1 << k) < n) {
            auto e = power(primitiveRoot<P>, 1 << (__builtin_ctz(P - 1) - k - 1));
            for (int i = 1 << (k - 1); i < (1 << k); i++) {
                roots<P>[2 * i] = roots<P>[i];
                roots<P>[2 * i + 1] = roots<P>[i] * e;
            }
            k++;
        }
    }
    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                MInt<P> u = a[i + j];
                MInt<P> v = a[i + j + k] * roots<P>[k + j];
                a[i + j] = u + v;
                a[i + j + k] = u - v;
            }
        }
    }
}
template<int P> constexpr void idft(vector<MInt<P>> &a) { // 逆变换
    int n = a.size();
    reverse(a.begin() + 1, a.end());
    dft(a);
    MInt<P> inv = (1 - P) / n;
    for (int i = 0; i < n; i++) {
        a[i] *= inv;
    }
}
```

## 快速傅里叶变换（FFT）

~~有萝莉控就要说了：$O(n^2)$我直接算不就行了。~~

所以下面进行优化。
$$
A(x)=\sum_{i=0}^{n-1} a_i x^{i}
$$
带入得过程中，我们将奇偶分开。
$$
A(x)=\sum_{i=0}^{\frac{n}{2}-1} a_{2i}x^{2i} +\sum_{i=0}^{\frac{n}{2}-1} a_{2i+1} x^{2i+1}
$$
分成了两部分，将$x^2$当成一个整体，有
$$
A(x)=A_1(x^2)+xA_2(x^2)
$$
假设我们带入的$\omega_{n}^{k}$，

若$k<\frac{n}{{2}}$：
$$
\begin{aligned}
A(\omega_{n}^{k})&=A_1(\omega_{n}^{2k})+\omega_{n}^{k}A_2(\omega_n^{2k})\\
&=A_1(w_{\frac{n}{2}}^{k})+\omega_{n}^{k}A_2(\omega_{\frac{n}{2}}^{k})
\end{aligned}
$$

$$
\begin{aligned}
A(\omega_{n}^{k+\frac{n}{2}})&=A_1(\omega_{n}^{2k+n})+\omega_{n}^{k+\frac{n}{2}}A_2(\omega_n^{2k+n})\\
&=A_1(\omega_{n}^{2k})+\omega_{n}^{k+\frac{n}{2}}A_2(\omega_n^{2k})\\
&=A_1(\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}A_2(\omega_{\frac{n}{2}}^{k})
\end{aligned}
$$

分治做即可$O(n\log n)$。

还有一些常数优化，就不介绍了，下面的板子跑得还是很快的 。

```cpp
struct Polynomial {
    constexpr static double PI = acos(-1);
    struct Complex {
        double x, y;
        Complex(double _x = 0.0, double _y = 0.0) {
            x = _x;
            y = _y;
        }
        Complex operator-(const Complex &rhs) const {
            return Complex(x - rhs.x, y - rhs.y);
        }
        Complex operator+(const Complex &rhs) const {
            return Complex(x + rhs.x, y + rhs.y);
        }
        Complex operator*(const Complex &rhs) const {
            return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);
        }
    };
    vector<Complex> c;
    Polynomial(vector<int> &a) {
        int n = a.size();
        c.resize(n);
        for (int i = 0; i < n; i++) {
            c[i] = Complex(a[i], 0);
        }
        fft(c, n, 1);
    }
    void change(vector<Complex> &a, int n) {
        for (int i = 1, j = n / 2; i < n - 1; i++) {
            if (i < j) swap(a[i], a[j]);
            int k = n / 2;
            while (j >= k) {
                j -= k;
                k /= 2;
            }
            if (j < k) j += k;
        }
    }
    void fft(vector<Complex> &a, int n, int opt) {
        change(a, n);
        for (int h = 2; h <= n; h *= 2) {
            Complex wn(cos(2 * PI / h), sin(opt * 2 * PI / h));
            for (int j = 0; j < n; j += h) {
                Complex w(1, 0);
                for (int k = j; k < j + h / 2; k++) {
                    Complex u = a[k];
                    Complex t = w * a[k + h / 2];
                    a[k] = u + t;
                    a[k + h / 2] = u - t;
                    w = w * wn;
                }
            }
        }
        if (opt == -1) {
            for (int i = 0; i < n; i++) {
                a[i].x /= n;
            }
        }
    }
};
```

## 快速数论变换（NTT）

FFT在复数域进行了大量的浮点运算，容易有精度问题。

NTT 解决的是多项式乘法带模数的情况。

我们需要找到在取模域上具有单位根相似性质的东西。

~~注意到~~原根和单位根很相似，用原根代替单位根即可。（为什么相似参考https://zhuanlan.zhihu.com/p/610073504）。

其余部分和FFT类似。

一些常见模数：

$998244353=7\times 17 \times 2^{23}+1,g=3$

$469762049=7\times 2^{26}+1,g=3$

$1004535809=479\times 2^{21}+1,g=3$

大模数：

$1,945,555,039,024,054,273=27\times 2^{56}+1,g=5$

$4,179,340,454,199,820,289=29\times 2^{57}+1,g=3$

```cpp
struct Polynomial {
    vector<Z> z;
    vector<int> r;
    Polynomial(vector<int> &a) {
        int n = a.size();
        z.resize(n);
        r.resize(n);
        for (int i = 0; i < n; i++) {
            z[i] = a[i];
            r[i] = (i & 1) * (n / 2) + r[i / 2] / 2;
        }
        ntt(z, n, 1);
    }
    LL power(LL a, int b) {
        LL res = 1;
        for (; b; b /= 2, a = a * a % mod) {
            if (b % 2) {
                res = res * a % mod;
            }
        }
        return res;
    }
    void ntt(vector<Z> &a, int n, int opt) {
        for (int i = 0; i < n; i++) {
            if (r[i] < i) {
                swap(a[i], a[r[i]]);
            }
        }
        for (int k = 2; k <= n; k *= 2) {
            Z gn = power(3, (mod - 1) / k);
            for (int i = 0; i < n; i += k) {
                Z g = 1;
                for (int j = 0; j < k / 2; j++, g *= gn) {
                    Z t = a[i + j + k / 2] * g;
                    a[i + j + k / 2] = a[i + j] - t;
                    a[i + j] = a[i + j] + t;
                }
            }
        }
        if (opt == -1) {
            reverse(a.begin() + 1, a.end());
            Z inv = power(n, mod - 2);
            for (int i = 0; i < n; i++) {
                a[i] *= inv;
            }
        }
    }
};
```



## 快速沃尔什变换（FWT）

我们通过每一项的贡献来计算FWT。
$$
FWT[A]_i=\sum_{j=0}^{n-1}c(i,j) A_j
$$
有以下性质
$$
c(i,j)c(i,k)=c(i,j\odot k)
$$
$\odot$表示位运算。

同时FWT每一位是独立贡献的。设$i_0,j_0$为最高位，$i',j'$为去掉最高位后的值。有
$$
c(i,j)=c(i_0,j_0)c(i',j')
$$
经过一系列分治推导，我们发现
$$
\begin{bmatrix}c(0,0) &c(0,1)\\c(1,0)&c(1,1) \end{bmatrix}
$$
就可以完成变换，我们称为**位矩阵**。

再通过求逆矩阵即可完成逆变换。
$$
A_i=\sum_{j=0}^{n-1}c^{-1}(i,j) FWT[A]_j
$$
因此我们只需要构造出存在逆矩阵且满足$c(i,j)c(i,k)=c(i,j\odot k)$的$2\times 2$矩阵，就可以完成变换。

这里还有一个比较重要的性质：**FWT 是线性变换。**故

FWT[A+B]=FWT[A]+FWT[B]。FWT[cA]=cFWT[A]

### k维FWT



# 参考资料

[GhostLX的博客](https://zhuanlan.zhihu.com/p/610073504)

[OIwiki](https://oi.wiki/math/poly/ntt/)

[胡小兔的OI博客](https://www.cnblogs.com/RabbitHu/p/FFT.html)
