# 网络流学习笔记

> 基本上不解释算法，提供模板，总结建模。

## 基本概念

**网络：**指的是一个带权有向图，并且有一个源点（s）和汇点（t）。

**容量：**边权为这条边的容量$c(u,v)$，若两点间没有边可以认为容量为0。

**流：**是一个边集映射到数集的一个函数，即经过某条边的流量，除源点，汇点外，其他点净流量（流出的流量和减去流入的流量和）为0，对于网络上的流$f$，定义其为s的净流量。

**割：**对于网络$G=(V,E)$，其顶点的划分$\{S,T\}$，若满足$s\in S,t \in T$，称其为$G$的一个割。其容量定义为
$$
\sum_{u \in S} \sum_{v \in T} c(u,v)
$$
所谓割，就是从网络中选择一些边，使得去掉这些边后，剩下两个不连通的分别包含源点和汇点的点集。割的大小是这些边的容量之和。
**增广路**，是从源点到汇点的路径，其上所有边的残余容量均大于0。



## 最大流问题

在网络$G=(V,E)$上指定流$f$，最大化整个网络的流量。或者说假定从源点流出的流量足够多，求能够流入汇点的最大流量。

通过Ford-Fulkerson算法，不断找增广路，就可以找出最大流。正确性和**最大流最小割定理**等价。

具体地：每次正向容量减少，反向容量加上相同的值。

### Dinic 算法

BFS分层+DFS增广

时间复杂度$O(V^2 E)$

```cpp
template<typename T> struct Flow_ {
    const int n;
    const T inf = numeric_limits<T>::max();
    struct Edge {
        int to;
        T w;
        Edge(int to, T w) : to(to), w(w) {}
    };
    vector<Edge> ver;  // 存所有边（正向边 + 反向边）
    vector<vector<int>> h;  // 邻接表，h[u] 存的是 ver 数组中的下标
    vector<int> cur, d;
    Flow_(int n) : n(n + 1), h(n + 1) {}
    void add(int u, int v, T c) {
        h[u].push_back(ver.size());
        ver.emplace_back(v, c);
        h[v].push_back(ver.size());
        ver.emplace_back(u, 0);
    }
    bool bfs(int s, int t) {
        d.assign(n, -1);
        d[s] = 0;
        queue<int> q;
        q.push(s);
        while (!q.empty()) {
            auto x = q.front();
            q.pop();
            for (auto it : h[x]) {
                auto [y, w] = ver[it];
                if (w && d[y] == -1) {
                    d[y] = d[x] + 1;
                    if (y == t) return true;
                    q.push(y);
                }
            }
        }
        return false;
    }
    T dfs(int u, int t, T f) {
        if (u == t) return f;
        auto r = f;
        for (int &i = cur[u]; i < h[u].size(); i++) {
            auto j = h[u][i];
            auto &[v, c] = ver[j];
            auto &[u, rc] = ver[j ^ 1];
            if (c && d[v] == d[u] + 1) {
                auto a = dfs(v, t, std::min(r, c));
                c -= a;
                rc += a;
                r -= a;
                if (!r) return f;
            }
        }
        return f - r;
    }
    T work(int s, int t) {
        T ans = 0;
        while (bfs(s, t)) {
            cur.assign(n, 0);
            ans += dfs(s, t, inf);
        }
        return ans;
    }
};
using Flow = Flow_<int>;
```

## 最小割问题

对一个网络求出一个割使得容量最小。

### 最大流最小割定理

最大流等于最小割

通过最大流最后一次bfs，就能找到无法到达的点，从而得到最小割。

如果需要在最小割的前提下最小化割边数量，$cap'=(E+1)*cap+1$。跑一遍最小割就可求出最小割边数量。

或者先求出原网络的最大流；再把可能的关键割边（即满流的边）容量置为 1，其余边容量置为 0；最后求出修改后网络的最大流.

```cpp
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    int S, T;
    // 输入格式示例： n m S T
    // 接着 m 行 u v cap（0-based 节点）
    if (!(cin >> n >> m >> S >> T)) return 0;

    struct E { int u, v; ll c; };
    vector<E> orig;
    orig.reserve(m);
    for (int i = 0; i < m; ++i) {
        int u, v; ll c;
        cin >> u >> v >> c;
        orig.push_back({u, v, c});
    }

    // B = m + 1
    ll B = (ll)m + 1;

    // 如果担心 cap * B 溢出，请使用 __int128 版（见下面）
    MaxFlow<ll> mf(n);
    for (auto &e : orig) {
        // 计算新的容量 cap' = c * B + 1
        // 注意：若 c * B 可能超过 64-bit，请改用 __int128 版本
        ll cp = e.c * B + 1;
        mf.addEdge(e.u, e.v, cp);
    }

    // 求最大流（新权重下）
    ll maxf_new = mf.flow(S, T);

    // 恢复最小割的 S 集（在你的模板 minCut 需要在 flow 之后调用）
    vector<bool> inS = mf.minCut();

    // 统计原始割容量与割边数
    ll cut_cap_sum = 0;
    int cut_edge_count = 0;
    for (auto &e : orig) {
        if (inS[e.u] && !inS[e.v]) {
            cut_cap_sum += e.c;
            ++cut_edge_count;
        }
    }

    cout << "原最小割容量 (sum of original caps) = " << cut_cap_sum << "\n";
    cout << "在该容量下的最小割边数 = " << cut_edge_count << "\n";

    // 可选：核对 new_flow 与 B,但注意溢出/精度问题
    // 当没有溢出时，下面关系成立： maxf_new = B * cut_cap_sum + cut_edge_count
    // 但我们更可靠地直接用 inS 计算上面的两个值
    // 输出 new flow 以便检验
    cout << "new_flow (B * cap + edges) = " << maxf_new << "\n";
    return 0;
}
```

如果没有最小割的前提（实际上就是忽略权重），直接把所有边的容量设成1，求一遍最小割就好了。

## 费用流（ **初始残量网络无负环**）

指**最小费用最大流（MCMF）**。每条边还有权重$\omega(x,y)$，最小费用最大流要求保证最大流时
$$
\sum_{(x,y)\in E} f(x,y) \times \omega(x,y)
$$
的最小值。

```cpp
template<class T>
struct MinCostFlow {
    struct _Edge {
        int to;
        T cap;
        T cost;
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };
    int n;
    vector<_Edge> e;
    vector<vector<int>> g;
    vector<T> h, dis;
    vector<int> pre;
    bool dijkstra(int s, int t) {
        dis.assign(n, numeric_limits<T>::max());
        pre.assign(n, -1);
        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> que;
        dis[s] = 0;
        que.emplace(0, s);
        while (!que.empty()) {
            T d = que.top().first;
            int u = que.top().second;
            que.pop();
            if (dis[u] != d) {
                continue;
            }
            for (int i : g[u]) {
                int v = e[i].to;
                T cap = e[i].cap;
                T cost = e[i].cost;
                if (cap > 0 && dis[v] > d + h[u] - h[v] + cost) {
                    dis[v] = d + h[u] - h[v] + cost;
                    pre[v] = i;
                    que.emplace(dis[v], v);
                }
            }
        }
        return dis[t] != numeric_limits<T>::max();
    }
    MinCostFlow() {}
    MinCostFlow(int n_) {
        init(n_);
    }
    void init(int n_) {
        n = n_;
        e.clear();
        g.assign(n, {});
    }
    void addEdge(int u, int v, T cap, T cost) {
        g[u].push_back(e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back(e.size());
        e.emplace_back(u, 0, -cost);
    }
    pair<T, T> flow(int s, int t) {
        T flow = 0;
        T cost = 0;
        h.assign(n, 0);
        while (dijkstra(s, t)) {
            for (int i = 0; i < n; ++i) {
                h[i] += dis[i];
            }
            T aug = numeric_limits<int>::max();
            for (int i = t; i != s; i = e[pre[i] ^ 1].to) {
                aug = min(aug, e[pre[i]].cap);
            }
            for (int i = t; i != s; i = e[pre[i] ^ 1].to) {
                e[pre[i]].cap -= aug;
                e[pre[i] ^ 1].cap += aug;
            }
            flow += aug;
            cost += aug * h[t];
        }
        return make_pair(flow, cost);
    }
    struct Edge {
        int from;
        int to;
        T cap;
        T cost;
        T flow;
    };
    vector<Edge> edges() {
        vector<Edge> a;
        for (int i = 0; i < e.size(); i += 2) {
            Edge x;
            x.from = e[i + 1].to;
            x.to = e[i].to;
            x.cap = e[i].cap + e[i + 1].cap;
            x.cost = e[i].cost;
            x.flow = e[i + 1].cap;
            a.push_back(x);
        }
        return a;
    }
};
```

这个在有负权边的时候，要用SPFA先初始势能，不如直接用SPFA。

```cpp
void spfa_init_potentials(int s) {
        const T INF = numeric_limits<T>::max() / 4;
        h.assign(n, INF);
        vector<char> inq(n, 0);
        queue<int> q;
        h[s] = 0;
        q.push(s);
        inq[s] = 1;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            inq[u] = 0;
            for (int idx : g[u]) {
                const _Edge &ed = e[idx];
                int v = ed.to;
                if (ed.cap > 0 && h[v] > h[u] + ed.cost) {
                    h[v] = h[u] + ed.cost;
                    if (!inq[v]) {
                        q.push(v);
                        inq[v] = 1;
                    }
                }
            }
        }
        // 把不可达的点势设为 0，避免后续计算中出现 INF
        for (int i = 0; i < n; ++i) if (h[i] == INF) h[i] = 0;
    }
```

## 上下界网络流

在原来基础上加上流量下界$b(u,v)$。$b(u,v)\le f(u,v) \le c(u,v)$

### 无源汇可行流

给定一个没有源点和汇点、每条边的流量有上下界的流量网络，问是否存在一种可行流使得流量平衡。

首先将下界流满，算出每个点的净流量$w_i$，若$w_i>0$，说明必须流出$w_i$，那就要新加流入$w_i$的边，同理$w_i<0$必须流入$w_i$，建立源点汇点，连接相应的边，再将原网络容量减去下界。

若汇点流满那么存在可行流，最后加上$b$即可。

### 有源汇可行流

加入一条从汇点连向源点的容量无穷大的，下界为0，的边即可转化为**无源汇可行流**。(目的是平衡流量)。

### 有源汇最大流

先跑求出可行流f1，然后去掉加的边，在残量网络求最大流f2。

### 有源汇最小流

根据 *S* 到 *T* 的最小流等于 *T*→*S* 的最大流的相反数这一结论，用可行流减掉 *G*′ 上 *T*→*S* 的最大流。即最大回退多少。

### 有源汇上下界最小费用可行流



## 一些性质

### 二分图

最小覆盖：即在所有顶点中选择最少的顶点来覆盖所有的边。

最大匹配：二分图左右两个点集中，选择有边相连的两个匹配成一对（每个点只能匹配一次），所能达到的最大匹配数。

独立集：集合中的任何两个点都不直接相连。

#### 二分图的最大匹配

**二分图的最大匹配**就是在二分图上跑出来的**最大流**。（并且最大流求二分图的最大匹配比匈牙利算法快）

#### 最小覆盖数 and 最大独立集

我们有**最小覆盖数=最大匹配数**，**最大独立集=总点数-最小覆盖集**两个性质。

#### 删边

在一个二分图中，如果删去一条边能够使这个图的最大匹配减小1的话，那么这条边一定在残量网络中满流，并且它所连接的两个点一定不在同一个强连通分量当中。

#### DAG最小路径覆盖

有一个DAG，要求用尽量少的不相交的简单路径覆盖所有的节点 。有**最小路径覆盖=原图节点数-新图最大匹配**新图指的是，将原来的点拆成两个点，如果$u \to v$，那么连接$u_x \to v_y$，这样得到的二分图的最大匹配。

> 一开始每个点都是独立的为一条路径，总共有n条不相交路径。我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。所以找到了几条匹配边，路径数就减少了多少。所以有最小路径覆盖=原图的结点数-新图的最大匹配数。

## 具体例题

+ [The 2022 ICPC Asia Xi'an Regional Contest ](https://qoj.ac/contest/1051) B. Cells Coloring 银牌题，选网格点转化成二分图匹配问题。

