# 网络流学习笔记

> 基本上不解释算法，提供模板，总结建模。

## 基本概念

**网络：**指的是一个带权有向图，并且有一个源点（s）和汇点（t）。

**容量：**边权为这条边的容量$c(u,v)$，若两点间没有边可以认为容量为0。

**流：**是一个边集映射到数集的一个函数，即经过某条边的流量，除源点，汇点外，其他点净流量（流出的流量和减去流入的流量和）为0，对于网络上的流$f$，定义其为s的净流量。

**割：**对于网络$G=(V,E)$，其顶点的划分$\{S,T\}$，若满足$s\in S,t \in T$，称其为$G$的一个割。其容量定义为
$$
\sum_{u \in S} \sum_{v \in T} c(u,v)
$$
所谓割，就是从网络中选择一些边，使得去掉这些边后，剩下两个不连通的分别包含源点和汇点的点集。割的大小是这些边的容量之和。
**增广路**，是从源点到汇点的路径，其上所有边的残余容量均大于0。



## 最大流问题

在网络$G=(V,E)$上指定流$f$，最大化整个网络的流量。或者说假定从源点流出的流量足够多，求能够流入汇点的最大流量。

通过Ford-Fulkerson算法，不断找增广路，就可以找出最大流。正确性和**最大流最小割定理**等价。

具体地：每次正向容量减少，反向容量加上相同的值。

### Dinic 算法

BFS分层+DFS增广

时间复杂度$O(V^2 E)$

```cpp
template<typename T> struct Flow_ {
    const int n;
    const T inf = numeric_limits<T>::max();
    struct Edge {
        int to;
        T w;
        Edge(int to, T w) : to(to), w(w) {}
    };
    vector<Edge> ver;  // 存所有边（正向边 + 反向边）
    vector<vector<int>> h;  // 邻接表，h[u] 存的是 ver 数组中的下标
    vector<int> cur, d;
    Flow_(int n) : n(n + 1), h(n + 1) {}
    void add(int u, int v, T c) {
        h[u].push_back(ver.size());
        ver.emplace_back(v, c);
        h[v].push_back(ver.size());
        ver.emplace_back(u, 0);
    }
    bool bfs(int s, int t) {
        d.assign(n, -1);
        d[s] = 0;
        queue<int> q;
        q.push(s);
        while (!q.empty()) {
            auto x = q.front();
            q.pop();
            for (auto it : h[x]) {
                auto [y, w] = ver[it];
                if (w && d[y] == -1) {
                    d[y] = d[x] + 1;
                    if (y == t) return true;
                    q.push(y);
                }
            }
        }
        return false;
    }
    T dfs(int u, int t, T f) {
        if (u == t) return f;
        auto r = f;
        for (int &i = cur[u]; i < h[u].size(); i++) {
            auto j = h[u][i];
            auto &[v, c] = ver[j];
            auto &[u, rc] = ver[j ^ 1];
            if (c && d[v] == d[u] + 1) {
                auto a = dfs(v, t, std::min(r, c));
                c -= a;
                rc += a;
                r -= a;
                if (!r) return f;
            }
        }
        return f - r;
    }
    T work(int s, int t) {
        T ans = 0;
        while (bfs(s, t)) {
            cur.assign(n, 0);
            ans += dfs(s, t, inf);
        }
        return ans;
    }
};
using Flow = Flow_<int>;
```

## 最小割问题

对一个网络求出一个割使得容量最小。

### 最大流最小割定理

最大流等于最小割

通过最大流最后一次bfs，就能找到无法到达的点，从而得到最小割。

如果需要在最小割的前提下最小化割边数量，$cap'=(E+1)*cap+1$。跑一遍最小割就可求出最小割边数量。

或者先求出原网络的最大流；再把可能的关键割边（即满流的边）容量置为 1，其余边容量置为 0；最后求出修改后网络的最大流.

```cpp
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    int S, T;
    // 输入格式示例： n m S T
    // 接着 m 行 u v cap（0-based 节点）
    if (!(cin >> n >> m >> S >> T)) return 0;

    struct E { int u, v; ll c; };
    vector<E> orig;
    orig.reserve(m);
    for (int i = 0; i < m; ++i) {
        int u, v; ll c;
        cin >> u >> v >> c;
        orig.push_back({u, v, c});
    }

    // B = m + 1
    ll B = (ll)m + 1;

    // 如果担心 cap * B 溢出，请使用 __int128 版（见下面）
    MaxFlow<ll> mf(n);
    for (auto &e : orig) {
        // 计算新的容量 cap' = c * B + 1
        // 注意：若 c * B 可能超过 64-bit，请改用 __int128 版本
        ll cp = e.c * B + 1;
        mf.addEdge(e.u, e.v, cp);
    }

    // 求最大流（新权重下）
    ll maxf_new = mf.flow(S, T);

    // 恢复最小割的 S 集（在你的模板 minCut 需要在 flow 之后调用）
    vector<bool> inS = mf.minCut();

    // 统计原始割容量与割边数
    ll cut_cap_sum = 0;
    int cut_edge_count = 0;
    for (auto &e : orig) {
        if (inS[e.u] && !inS[e.v]) {
            cut_cap_sum += e.c;
            ++cut_edge_count;
        }
    }

    cout << "原最小割容量 (sum of original caps) = " << cut_cap_sum << "\n";
    cout << "在该容量下的最小割边数 = " << cut_edge_count << "\n";

    // 可选：核对 new_flow 与 B,但注意溢出/精度问题
    // 当没有溢出时，下面关系成立： maxf_new = B * cut_cap_sum + cut_edge_count
    // 但我们更可靠地直接用 inS 计算上面的两个值
    // 输出 new flow 以便检验
    cout << "new_flow (B * cap + edges) = " << maxf_new << "\n";
    return 0;
}
```

如果没有最小割的前提（实际上就是忽略权重），直接把所有边的容量设成1，求一遍最小割就好了。

## 费用流（ **初始残量网络无负环**）

指**最小费用最大流（MCMF）**。每条边还有权重$\omega(x,y)$，最小费用最大流要求保证最大流时
$$
\sum_{(x,y)\in E} f(x,y) \times \omega(x,y)
$$
的最小值。

```cpp
template<class T>
struct MinCostFlow {
    struct _Edge {
        int to;
        T cap;
        T cost;
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };
    int n;
    vector<_Edge> e;
    vector<vector<int>> g;
    vector<T> h, dis;
    vector<int> pre;
    bool dijkstra(int s, int t) {
        dis.assign(n, numeric_limits<T>::max());
        pre.assign(n, -1);
        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> que;
        dis[s] = 0;
        que.emplace(0, s);
        while (!que.empty()) {
            T d = que.top().first;
            int u = que.top().second;
            que.pop();
            if (dis[u] != d) {
                continue;
            }
            for (int i : g[u]) {
                int v = e[i].to;
                T cap = e[i].cap;
                T cost = e[i].cost;
                if (cap > 0 && dis[v] > d + h[u] - h[v] + cost) {
                    dis[v] = d + h[u] - h[v] + cost;
                    pre[v] = i;
                    que.emplace(dis[v], v);
                }
            }
        }
        return dis[t] != numeric_limits<T>::max();
    }
    MinCostFlow() {}
    MinCostFlow(int n_) {
        init(n_);
    }
    void init(int n_) {
        n = n_;
        e.clear();
        g.assign(n, {});
    }
    void addEdge(int u, int v, T cap, T cost) {
        g[u].push_back(e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back(e.size());
        e.emplace_back(u, 0, -cost);
    }
    pair<T, T> flow(int s, int t) {
        T flow = 0;
        T cost = 0;
        h.assign(n, 0);
        while (dijkstra(s, t)) {
            for (int i = 0; i < n; ++i) {
                h[i] += dis[i];
            }
            T aug = numeric_limits<int>::max();
            for (int i = t; i != s; i = e[pre[i] ^ 1].to) {
                aug = min(aug, e[pre[i]].cap);
            }
            for (int i = t; i != s; i = e[pre[i] ^ 1].to) {
                e[pre[i]].cap -= aug;
                e[pre[i] ^ 1].cap += aug;
            }
            flow += aug;
            cost += aug * h[t];
        }
        return make_pair(flow, cost);
    }
    struct Edge {
        int from;
        int to;
        T cap;
        T cost;
        T flow;
    };
    vector<Edge> edges() {
        vector<Edge> a;
        for (int i = 0; i < e.size(); i += 2) {
            Edge x;
            x.from = e[i + 1].to;
            x.to = e[i].to;
            x.cap = e[i].cap + e[i + 1].cap;
            x.cost = e[i].cost;
            x.flow = e[i + 1].cap;
            a.push_back(x);
        }
        return a;
    }
};
```

这个在有负权边的时候，要用SPFA先初始势能，不如直接用SPFA。

```cpp
void spfa_init_potentials(int s) {
        const T INF = numeric_limits<T>::max() / 4;
        h.assign(n, INF);
        vector<char> inq(n, 0);
        queue<int> q;
        h[s] = 0;
        q.push(s);
        inq[s] = 1;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            inq[u] = 0;
            for (int idx : g[u]) {
                const _Edge &ed = e[idx];
                int v = ed.to;
                if (ed.cap > 0 && h[v] > h[u] + ed.cost) {
                    h[v] = h[u] + ed.cost;
                    if (!inq[v]) {
                        q.push(v);
                        inq[v] = 1;
                    }
                }
            }
        }
        // 把不可达的点势设为 0，避免后续计算中出现 INF
        for (int i = 0; i < n; ++i) if (h[i] == INF) h[i] = 0;
    }
```

